# 100 Days Of Code - Log

### Day 1: 12, May 2024 

**Today's Progress**: Started adding web3 to a node/react project. Begun by adding Privy login to the embed wallet of the submissions app

**Thoughts:** This was painfully easy... but may not work long term. Currently my app is on create-react-app which requires Typescript 5<. Privy requires typescript 5>. I tried to set some overrides for a while but then gave up.

**Link to work:** pushed 

### Day2
**Today's Progress**:: I noticed yesterday that the submission period check (which was meant to be open all week), wasn't working on Sundays yesterday. I fixed it by working out that JS starts Sundays at zero (to saturday's 6) instead of Monday's at zero. Once adjusted, it worked. I then moved back to privy and specificially the 'authenticated' option. I added an IF statement
**Thoughts:** - Privy is great. 

### Day3
**Today's Progress**:: mostly back and forth with gpt on the best way to run the voting component of submissions; onchain or offchain. The hypothesis for now is a hybrid approach. Vote power is calculated via a smart contract based on tokens in a wallet. Vote tallying & result itself is via our server due to our requirement to have a centralised veto for now. We can transfer this to onchain vote plus multisig veto later... but lets not deal with gas and robustness problems right now.After this decision, I looked for a very basic vote power snapshot contract on base sepolia but couldn't find one. So for now I'll write my own. I then spent the rest of my time, setting up my environment for contract work. That took ages. Just in 5 mins I took a template of the votepower.sol contract and deploy.js gpt gave me and shoved it in. I'll pick up reviewing these tomorrow
**Thoughts:** - Dev environment versioning sucks... but gpt does get there in the end. I'm not entirely happy using my own voting snapshot contract. this must exist already on base sepolia so will keep searching

### Day4
**Today's Progress**:: went back through the templates of votepower.sol / deploy.js. Commented up to make sure I understand it fully. I then tried to test the contracts via command line/hardhat... kept getting an error ('TypeError: votePower.deployed is not a function'). No solution yet. UPDATE - founda  solution. It was due to ethers6 updating how we call stuff (e.g not contract factory). updates made to deploy.js to adjust. Was able too deploy and then check vote power on an address (yay)
**Thoughts:** - hardhat is tricky... but helpful. 

### Day5
**Today's Progress**:: swapped out degen - which I had zero vote power - for a sepolia erc-20 token that I deployed. Added code to my server.ts to grab the users vote power . Server runs but fails in the front-end. Hard to test with postman too as need a wallet. Will implement front-end code before testing. 
**Thoughts:** - 

### Day6
**Today's Progress**:: should have stayed in the backend. Tonne of errors. Givev up until tomorrow

### Day7
**Today's Progress**:: fixed the backend issues. It was a mixture of there being no ABI input, the alchemykey not being called from dotenv correctly, the getVotePower function not storing data as the right combinations of string/number/big number etc. Once I did these changes it worked. however, I realised the vote power can be used continually to vote. I then added backend functionality to only let a wallet vote once in a set period. This will do for now (though note that when the token is transferable, this won't work as they can just move the vote power to a different address). The front-end now also got updated to send a nice notification if they try and vote twice (before the app just crashed)
**Thoughts:** - lesson here is not just to try and do all the backend, frontend code all at once and then debug. A lot easier to just do it piece by piece and track errors as I go. 

### Day8
**Today's Progress**: set up routers so we can move to a multipage site. Updated the homepage.tsx to work with our backend (i.e. display a 'no market live yet message', then receive a title for a proxy, voted on prediction market from the nextweek page, display that title once its chosen). Now will spend the rest of the day deciding how to do the prediction market aspect (onchain, offchain, hybrid). 
**Thoughts:** - this isn't going to be easy

### Day9
**Today's Progress**: spent the day in research with gpt instead of implementation. In short, no point me going further with the front-end / databasing until I know how i'm doing the hardest part. The prediction market itself. It seems Omen (gnosis) does onchain AMM market, offchain matching, onchain trading of shares as 1155s, onchain execution. It seems polymarket, does offchain market, offchain matching and trading of shares onchain. I got some templates generated for how to do the making with smart contracts, the matching with a server and the trading onchain. I'll ask for some advice today and then implement tomorrow.
**Thoughts:** - This is getting very deep. Might try and get some advice before I pick a path
### Day10
**Today's Progress**: leaving the homepage prediction market for now. Gonna get some advice on it first. For now, I'm going to setup the database so the data for submissions at least is persistent. Decided on using mongodb mostly as it uses json which is easier for me to pick up than postgresql. I imported mongoose. set my dotenv variables and then connected successfully to mongo in my server. I also then pasted some templates for making my get / post submissions working in mongo. They worked for storing and posting from postman... BUT the votign and setting live market now failed. Something to do with the ID changing (the id changed location in the api's deliverable. This probably just needs some tweaks to the vote/reset functions)
**Thoughts:** - databasing seemed easy for submissions. Again most worried for when this scales up to the prediction market/order matching. Onchain might be better
### Day11
**Today's Progress**: okay, I updated the vote, set-live-market and get-winner functionality in server.ts. They now work with mongo and persistently. I noticed that the User can vote twice in a submission period again if the server resets.. so created a mongodb model and stored the check on user votes in the database too.
to-do gaps in functionality. 1. Reset will reset submissions forever. 2. Front-end is compatible with voting yet

### Day12
**Today's Progress**: didn't do much today as was travelling for work. Spent the plane ride architecting the AMM. Decided I'm going to implement it myself once done with with the database integration

### Day13
**Today's Progress**: okay, back to databasing. Targeted making front-end compatible so voting works. Took a while but saw that the submissions object now had 'submissions._id' instead of submissions.id which meant the id was undefined. Just changing the html though didn't work. Our server.ts interface needed updating too. This now works

### Day14
**Today's Progress**: okay, took the plunge and decided to start implementing contracts for the AMM. I've just taken some templates for .sol files. Will review them tomorrow

### Day15
**Today's Progress**: travel day

### Day16
**Today's Progress**: forgot to push this, but yesterday I reviewed how the proposed contracts are setup and then adjusted the deploy.js. I haven't tried compiling yet. Will bug fix tomorrow

### Day17
**Today's Progress**: 'had to wrap conditional tokens in a wrapper with a higher contract. Tweaked other compatibility stuff. Contracts now compiled and deployed. Front-end integration next'


### Day18
**Today's Progress**: updated server.ts to push my live market onchain on submission period end. I still get an error when I do this though so need to check this next'

### Day19
**Today's Progress**:'still trying to sort out the server calls of the contracts. Function calls are named wrong. Still erroring but am closer'

### Day20
**Today's Progress**:'good news. The condition for the conditional token is now preparing. The problem was we passed the ERC20 address to the tokenswrapper. We needed to pass a ConditionalTokens.sol into the wrapper. I created this, referenced IConditionalTokens, and got it working. Now The MarketMaker is erroring out. So will move onto that'
**Extra Progress**- so turns out there was still error. It worked on the first server run but failed everytime after as questionID has to be unique each time. I made the ID unique each time by combining the hash with a timestamp

TO DO IDEAS:
Essentials for Later Development
Persistent Data Storage:
Database Integration: Replace the in-memory storage with a database like MongoDB, PostgreSQL, or similar. This will ensure that your data persists across server restarts and can be scaled as your application grows.
Data Models: Define robust data models/schema for submissions and votes. This helps in managing and querying data more efficiently.
Authentication and Authorization:
Allow vote power based on onchain tokens in embedded or EOA wallet
Robust Error Handling: Implement comprehensive error handling in the backend to manage and respond to errors gracefully.
Data Validation: Validate incoming data to prevent incorrect or malicious data from being processed.
Nice-to-Haves for Enhanced Functionality
Real-Time Updates:
WebSockets or Polling: Implement WebSockets for a real-time user experience, especially for displaying live voting results and market data updates.
Push Notifications: Inform users about important events (e.g., market changes, voting results) through real-time notifications.
Advanced Market Features:
Dynamic Pricing Algorithm: Implement or integrate a more complex algorithm for better prediction market dynamics.
Historical Data Analysis: Provide historical analysis of market predictions and outcomes to enhance user trust and engagement.
User Experience Improvements:
Interactive UI Components: Enhance the frontend with interactive charts and visualizations using libraries like D3.js or Chart.js for market data.
Mobile Optimization: Ensure the application is fully responsive and optimized for mobile devices.
Security Enhancements:
Rate Limiting: Prevent abuse by limiting how frequently a user can make requests to the API.
Audit and Monitoring: Implement logging and monitoring to detect unusual activities or performance issues.
Scalability Considerations:
Load Balancing: Prepare for scaling your application with load balancing techniques.
Microservices Architecture: If expecting significant growth, consider adopting a microservices architecture to make scaling individual components of your app easier.